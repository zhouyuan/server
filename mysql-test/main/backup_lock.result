#
# testing LOCKs BACKUP STAGE
#
connect  con1,localhost,root,,;
connect  con2,localhost,root,,;
connection default;
#
# testing if BACKUP STAGE FLUSH causes deadlocks with ALTER TABLE
#
create table t1 (a int) engine=innodb;
start transaction;
insert into t1 values (1);
connection con1;
alter table t1 add column (j int);
connection con2;
backup stage start;
backup stage flush;
SET STATEMENT max_statement_time=1 FOR backup stage block_ddl;
ERROR 70100: Query execution was interrupted (max_statement_time exceeded)
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
LOCK_MODE	LOCK_TYPE	TABLE_SCHEMA	TABLE_NAME
MDL_BACKUP_DDL	Backup lock		
MDL_BACKUP_FLUSH	Backup lock		
MDL_SHARED_WRITE	Table metadata lock	test	t1
MDL_SHARED_UPGRADABLE	Table metadata lock	test	t1
MDL_INTENTION_EXCLUSIVE	Schema metadata lock	test	
backup stage block_ddl;
connection default;
commit;
SET STATEMENT max_statement_time=1 FOR SELECT * FROM t1;
ERROR 70100: Query execution was interrupted (max_statement_time exceeded)
SELECT * FROM t1;
connection con2;
backup stage end;
connection con1;
connection default;
a	j
1	NULL
drop table t1;
#
# testing if BACKUP STAGE FLUSH causes deadlocks with DROP TABLE
#
create table t1 (a int) engine=innodb;
start transaction;
insert into t1 values (1);
connection con1;
SET STATEMENT max_statement_time=1 FOR DROP TABLE t1;
ERROR 70100: Query execution was interrupted (max_statement_time exceeded)
DROP TABLE t1;
connection con2;
backup stage start;
backup stage flush;
SET STATEMENT max_statement_time=1 FOR SELECT * FROM t1;
ERROR 70100: Query execution was interrupted (max_statement_time exceeded)
SET STATEMENT max_statement_time=1 FOR backup stage block_ddl;
ERROR 70100: Query execution was interrupted (max_statement_time exceeded)
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
LOCK_MODE	LOCK_TYPE	TABLE_SCHEMA	TABLE_NAME
MDL_BACKUP_DDL	Backup lock		
MDL_BACKUP_FLUSH	Backup lock		
MDL_SHARED_WRITE	Table metadata lock	test	t1
MDL_INTENTION_EXCLUSIVE	Schema metadata lock	test	
backup stage end;
select user,db,Info from information_schema.processlist where user <> "system user" order by Info;
user	db	Info
root	test	NULL
root	test	DROP TABLE t1
root	test	select user,db,Info from information_schema.processlist where user <> "system user" order by Info
connection default;
commit;
connection con1;
connection default;
#
# Check if backup stage block_dll + concurrent drop table blocks select
#
create table t1 (a int) engine=innodb;
backup stage start;
backup stage block_ddl;
connection con1;
DROP TABLE t1;
connection con2;
connection con2;
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
LOCK_MODE	LOCK_TYPE	TABLE_SCHEMA	TABLE_NAME
MDL_BACKUP_WAIT_DDL	Backup lock		
SET STATEMENT max_statement_time=1 FOR SELECT * FROM t1;
a
connection default;
backup stage end;
connection con1;
connection default;
#
# Check if backup stage block_dll overrides ddl lock for drop table
#
create table t1 (a int) engine=innodb;
start transaction;
insert into t1 values (1);
connection con1;
SET STATEMENT max_statement_time=1 FOR DROP TABLE t1;
ERROR 70100: Query execution was interrupted (max_statement_time exceeded)
DROP TABLE t1;
connection con2;
backup stage start;
backup stage flush;
backup stage block_ddl;
connection default;
commit;
connection con2;
backup stage end;
connection con1;
connection default;
#
# Check if BACKUP STAGE BLOCK_COMMIT blocks commit
#
create table t1 (a int) engine=innodb;
start transaction;
insert into t1 values (1);
connection con1;
backup stage start;
backup stage block_commit;
connection default;
commit;
connection con1;
backup stage end;
connection default;
select * from t1;
a
1
drop table t1;
disconnect con1;
disconnect con2;
#
# Test backup stage and flush tables
# Part of "MDEV-5336 Implement LOCK FOR BACKUP" tests
#
BACKUP STAGE START ;
BACKUP STAGE BLOCK_DDL ;
FLUSH TABLES;
CREATE TEMPORARY TABLE t12345678_tmp (col1 INT);
drop table t12345678_tmp;
BACKUP STAGE END;
#
# Test BACKUP STAGES with lock timeouts
#
SET GLOBAL lock_wait_timeout=1;
CREATE TABLE t_permanent_innodb (col1 INT) ENGINE = InnoDB;
CREATE TABLE t_permanent_myisam (col1 INT) ENGINE = MyISAM;
INSERT INTO t_permanent_innodb SET col1 = 1;
INSERT INTO t_permanent_myisam SET col1 = 1;
CREATE TABLE t_con1_innodb (col1 INT) ENGINE = InnoDB;
CREATE TABLE t_con1_myisam (col1 INT) ENGINE = MyISAM;
connect con1,localhost,root,,;
SET AUTOCOMMIT = 0;
connection default;
BACKUP STAGE START;
BACKUP STAGE FLUSH;
BACKUP STAGE BLOCK_DDL;
BACKUP STAGE BLOCK_COMMIT;
unlock tables;
connection con1;
UPDATE t_permanent_innodb SET col1 = 8;
UPDATE t_permanent_myisam SET col1 = 8;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
DROP TABLE t_con1_innodb;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
DROP TABLE t_con1_myisam;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
connection default;
BACKUP STAGE END;
DROP TABLE t_permanent_myisam, t_permanent_innodb;
DROP TABLE t_con1_innodb, t_con1_myisam;
disconnect con1;
set global lock_wait_timeout=default;
