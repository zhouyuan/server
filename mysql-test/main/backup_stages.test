--source include/have_innodb.inc
--source include/have_metadata_lock_info.inc

--echo #
--echo # testing syntax for BACKUP STAGE
--echo #

backup stage start;
backup stage end;

--error ER_BACKUP_UNKNOWN_STAGE
backup stage not_existing;
backup stage start;
backup stage flush;
--error ER_BACKUP_WRONG_STAGE
backup stage start;
--error ER_BACKUP_WRONG_STAGE
backup stage start;
backup stage block_commit;
--error ER_BACKUP_WRONG_STAGE
backup stage flush;
--error ER_BACKUP_WRONG_STAGE
backup stage flush;
backup stage end;
--error ER_BACKUP_NOT_RUNNING
backup stage flush;

--echo #
--echo # Check backup and FTWRL
--echo #
flush tables with read lock;
--error ER_CANT_UPDATE_WITH_READLOCK
backup stage start;
unlock tables;
backup stage start;
--error ER_BACKUP_LOCK_IS_ACTIVE
flush tables with read lock;
backup stage end;

--echo #
--echo # Check Oracle syntax
--echo #
set SQL_MODE=Oracle;
backup stage start;
backup stage end;
set SQL_MODE=default;

--echo #
--echo # Check BACKUP STAGE under lock tables
--echo #
create table t1 (a int);
lock table t1 write;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
backup stage start;
--error ER_BACKUP_NOT_RUNNING
backup stage end;
unlock tables;

lock table t1 read;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
backup stage start;
--error ER_BACKUP_NOT_RUNNING
backup stage end;
unlock tables;


--echo #
--echo # Check lock tables under BACKUP STAGE
--echo #
backup stage start;
unlock tables;
select lock_mode from information_schema.metadata_lock_info;

--error ER_BACKUP_LOCK_IS_ACTIVE
lock table t1 write;
--error ER_BACKUP_LOCK_IS_ACTIVE
lock table t1 read;
unlock tables;
backup stage end;
drop table t1;


--echo #
--echo # Check setting readonly under BACKUP STAGE
--echo #
backup stage start;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
set @@global.read_only=1;
backup stage end;

--echo # also make sure going back from read-only mode is not allowed
set @@global.read_only=1;
backup stage start;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
set @@global.read_only=0;
backup stage end;
set @@global.read_only=0;

--echo #
--echo # Check BACKUP STAGE under read_only
--echo #

set @@global.read_only=1;
backup stage start;
backup stage end;
set @@global.read_only=0;

--echo #
--echo # Check that we can't create tables during backup
--echo #

backup stage start;
--error ER_BACKUP_LOCK_IS_ACTIVE
create table t1 (a int);
backup stage end;

--echo # also make sure we can't write to a table during backup
create table t1(a INT);
backup stage start;
--error ER_BACKUP_LOCK_IS_ACTIVE
insert into t1 values(1);
--error ER_BACKUP_LOCK_IS_ACTIVE
insert delayed into t1 values(1);
--error ER_BACKUP_LOCK_IS_ACTIVE
update t1 set a=1;
--error ER_BACKUP_LOCK_IS_ACTIVE
delete from t1;
--error ER_BACKUP_LOCK_IS_ACTIVE
truncate table t1;
--error ER_BACKUP_LOCK_IS_ACTIVE
drop table t1;
backup stage end;
drop table t1;

--echo #
--echo # CHECK: BACKUP STAGE must perform implicit commit
--echo #
create table t1(a int) engine=InnoDB;
begin;
insert into t1 values(1);
select lock_mode from information_schema.metadata_lock_info;
backup stage start;
select lock_mode from information_schema.metadata_lock_info;
backup stage block_commit;
commit;
backup stage end;

--echo #
--echo # CHECK: RO transaction under BACKUP STAGE is a potential deadlock
--echo # OTOH we most probably allow them under FTWRL as well
--echo #
backup stage start;
backup stage block_commit;
begin;
select * from t1;
select lock_mode from information_schema.metadata_lock_info;
backup stage end;
select lock_mode from information_schema.metadata_lock_info;
drop table t1;

--echo #
--echo # Check TEMPORARY TABLES
--echo #

BACKUP STAGE START;
BACKUP STAGE BLOCK_DDL;
FLUSH TABLES;
CREATE TEMPORARY TABLE tmp (col1 INT);
DROP TEMPORARY TABLE tmp;
BACKUP STAGE END;

--echo #
--echo # Testing which locks we get from all stages
--echo #

BACKUP STAGE START;
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
BACKUP STAGE FLUSH;
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
BACKUP STAGE BLOCK_DDL;
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
BACKUP STAGE BLOCK_COMMIT;
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
BACKUP STAGE END;
SELECT LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME FROM information_schema.metadata_lock_info;
